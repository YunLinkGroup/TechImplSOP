## 阿里云 Ubuntu 22.4 三节点集群（美国硅谷）部署 Kubernetes 1.33

### 组网

集群信息

集群概况

| 实例ID                 | 名称  | IP       | 主机名                  |
| ---------------------- | ----- | -------- | ----------------------- |
| i-rj9976wzpibxv39zlxv3 | node1 | 10.0.1.1 | iZrj9976wzpibxv39zlxv3Z |
| i-rj9b9nu5j7lbkcipzqj1 | node2 | 10.0.1.2 | iZrj9b9nu5j7lbkcipzqj1Z |
| i-rj9hztrcp8hoxgfe9x8c | node3 | 10.0.1.3 | iZrj9hztrcp8hoxgfe9x8cZ |

节点概况

三个节点配置相同。

| 大类     | 资源               | 配置                      | 备注                  |
| -------- | ------------------ | ------------------------- | --------------------- |
| 基础信息 | 实例ID             | ...                       |                       |
|          | 名称               | ...                       | 自定义                |
|          | 地域/可用区        | 美国（硅谷）/可用区A      | 影响延迟与容灾        |
| 计算     | 实例规格           | ecs.c8i.xlarge            | 4 vCPU 8 GiB          |
|          | CPU利用率(7d峰值)  | 2 %                       | 云监控数据            |
| 内存     | 内存容量           | 8 GiB                     |                       |
|          | 内存利用率(7d峰值) | 15 %                      |                       |
| 存储     | 系统盘             | 50 GiB ESSD Entry         |                       |
|          | 数据盘             |                           |                       |
| 网络     | 专有网络VPC        | vpc-rj9y86j6gag9djuvyh6cw | IPv4网段：10.0.0.0/16 |
|          | 交换机             | vsw-rj97amv6sv9jrx3zhnwli | IPv4网段：10.0.1.0/24 |
|          | 公网IP/EIP         | ...                       | 8 Mbps                |
| 镜像     | 操作系统           | Ubuntu 24.04 64bit        |                       |
| 安全     | 安全组             | sg-rj9976wzpibxv39wgzak   | 允许 22、3389、6443   |

### 禁用交换空间

```shell
# 临时关闭交换空间
sudo swapoff -a
# 将
sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
```



### 加载内核模块

```shell
# 临时加载模块（重启后失效）
# modprobe 用于 Linux 动态加载/卸载内核模块
sudo modprobe overlay
sudo modprobe br_netfilter
# 永久加载模块
sudo tee /etc/modules-load.d/k8s.conf <<EOF
overlay
br_netfilter
EOF
```





```shell
sudo tee /etc/sysctl.d/kubernetes.conf <<EOF
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
EOF
sudo sysctl --system
```





### 安装容器运行时

在每个节点进行相同操作。容器运行时采用 containerd。

```shell
# 安装前置依赖
sudo apt install -y curl gnupg2 software-properties-common apt-transport-https ca-certificates

# 添加 containerd 存储库
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmour -o /etc/apt/trusted.gpg.d/containerd.gpg
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

# 安装 containerd
sudo apt update
sudo apt install containerd.io -y

# 
containerd config default | sudo tee /etc/containerd/config.toml >/dev/null 2>&1
sudo sed -i 's/SystemdCgroup \= false/SystemdCgroup \= true/g' /etc/containerd/config.toml

# 重启 containerd 使得更改生效
sudo systemctl restart containerd
```





### 安装 k8s

在每个节点进行相同操作。

https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/#install-using-native-package-management

```shell
# Kubernetes 软件包在 Ubuntu 24.04 的默认包存储库中不可用，故需要添加存储库然后进行安装。
# 使用 curl 命令下载 Kubernetes 包存储库的公共签名密钥。
curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.33/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg

# 添加 Kubernetes apt 仓库
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.33/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

# 安装 kubelet kubeadm kubectl 工具
sudo apt update
sudo apt install kubelet kubeadm kubectl -y
```







### 集群初始化

主节点执行初始化

- `--control-plane-endpoint`为主节点IP地址

```shell
sudo kubeadm init --control-plane-endpoint=10.0.1.1
```

```shell
root@iZrj9976wzpibxv39zlxv3Z:~# sudo kubeadm init --control-plane-endpoint=10.0.1.1
[init] Using Kubernetes version: v1.33.3
[preflight] Running pre-flight checks
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action beforehand using 'kubeadm config images pull'
W0814 00:37:57.883097    7459 checks.go:846] detected that the sandbox image "registry.k8s.io/pause:3.8" of the container runtime is inconsistent with that used by kubeadm.It is recommended to use "registry.k8s.io/pause:3.10" as the CRI sandbox image.
[certs] Using certificateDir folder "/etc/kubernetes/pki"
[certs] Generating "ca" certificate and key
[certs] Generating "apiserver" certificate and key
[certs] apiserver serving cert is signed for DNS names [izrj9976wzpibxv39zlxv3z kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.0.1.1]
[certs] Generating "apiserver-kubelet-client" certificate and key
[certs] Generating "front-proxy-ca" certificate and key
[certs] Generating "front-proxy-client" certificate and key
[certs] Generating "etcd/ca" certificate and key
[certs] Generating "etcd/server" certificate and key
[certs] etcd/server serving cert is signed for DNS names [izrj9976wzpibxv39zlxv3z localhost] and IPs [10.0.1.1 127.0.0.1 ::1]
[certs] Generating "etcd/peer" certificate and key
[certs] etcd/peer serving cert is signed for DNS names [izrj9976wzpibxv39zlxv3z localhost] and IPs [10.0.1.1 127.0.0.1 ::1]
[certs] Generating "etcd/healthcheck-client" certificate and key
[certs] Generating "apiserver-etcd-client" certificate and key
[certs] Generating "sa" key and public key
[kubeconfig] Using kubeconfig folder "/etc/kubernetes"
[kubeconfig] Writing "admin.conf" kubeconfig file
[kubeconfig] Writing "super-admin.conf" kubeconfig file
[kubeconfig] Writing "kubelet.conf" kubeconfig file
[kubeconfig] Writing "controller-manager.conf" kubeconfig file
[kubeconfig] Writing "scheduler.conf" kubeconfig file
[etcd] Creating static Pod manifest for local etcd in "/etc/kubernetes/manifests"
[control-plane] Using manifest folder "/etc/kubernetes/manifests"
[control-plane] Creating static Pod manifest for "kube-apiserver"
[control-plane] Creating static Pod manifest for "kube-controller-manager"
[control-plane] Creating static Pod manifest for "kube-scheduler"
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Starting the kubelet
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory "/etc/kubernetes/manifests"
[kubelet-check] Waiting for a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s
[kubelet-check] The kubelet is healthy after 501.323647ms
[control-plane-check] Waiting for healthy control plane components. This can take up to 4m0s
[control-plane-check] Checking kube-apiserver at https://10.0.1.1:6443/livez
[control-plane-check] Checking kube-controller-manager at https://127.0.0.1:10257/healthz
[control-plane-check] Checking kube-scheduler at https://127.0.0.1:10259/livez
[control-plane-check] kube-controller-manager is healthy after 1.634933149s
[control-plane-check] kube-scheduler is healthy after 1.931743994s
[control-plane-check] kube-apiserver is healthy after 3.500579433s
[upload-config] Storing the configuration used in ConfigMap "kubeadm-config" in the "kube-system" Namespace
[kubelet] Creating a ConfigMap "kubelet-config" in namespace kube-system with the configuration for the kubelets in the cluster
[upload-certs] Skipping phase. Please see --upload-certs
[mark-control-plane] Marking the node izrj9976wzpibxv39zlxv3z as control-plane by adding the labels: [node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]
[mark-control-plane] Marking the node izrj9976wzpibxv39zlxv3z as control-plane by adding the taints [node-role.kubernetes.io/control-plane:NoSchedule]
[bootstrap-token] Using token: jgb353.v9qxwp1uic5944zj
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to get nodes
[bootstrap-token] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstrap-token] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstrap-token] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstrap-token] Creating the "cluster-info" ConfigMap in the "kube-public" namespace
[kubelet-finalize] Updating "/etc/kubernetes/kubelet.conf" to point to a rotatable kubelet client certificate and key
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now join any number of control-plane nodes by copying certificate authorities
and service account keys on each node and then running the following as root:

  kubeadm join 10.0.1.1:6443 --token jgb353.v9qxwp1uic5944zj \
        --discovery-token-ca-cert-hash sha256:c9a75316ca750f7e1fb350f5059d575f3c6dff85c501a256927ab681787f1b6a \
        --control-plane 

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join 10.0.1.1:6443 --token jgb353.v9qxwp1uic5944zj \
        --discovery-token-ca-cert-hash sha256:c9a75316ca750f7e1fb350f5059d575f3c6dff85c501a256927ab681787f1b6a
```



主节点



```
vi ~/.bashrc
export KUBECONFIG=/etc/kubernetes/admin.conf
source ~/.bashrc
```





在主节点安装网络插件（以 calico 为例）

```shell
kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml
```

将工作节点加入集群

每一个工作节点均需要执行一次。

```shell
root@iZrj9b9nu5j7lbkcipzqj1Z:~# kubeadm join 10.0.1.1:6443 --token jgb353.v9qxwp1uic5944zj \
        --discovery-token-ca-cert-hash sha256:c9a75316ca750f7e1fb350f5059d575f3c6dff85c501a256927ab681787f1b6a
[preflight] Running pre-flight checks
[preflight] Reading configuration from the "kubeadm-config" ConfigMap in namespace "kube-system"...
[preflight] Use 'kubeadm init phase upload-config --config your-config-file' to re-upload it.
[kubelet-start] Writing kubelet configuration to file "/var/lib/kubelet/config.yaml"
[kubelet-start] Writing kubelet environment file with flags to file "/var/lib/kubelet/kubeadm-flags.env"
[kubelet-start] Starting the kubelet
[kubelet-check] Waiting for a healthy kubelet at http://127.0.0.1:10248/healthz. This can take up to 4m0s
[kubelet-check] The kubelet is healthy after 1.000644935s
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.
```



在主节点获取集群各节点状态，工作节点刚加入集群处于 NotReady，约1到2分钟后会变为Ready。

```shell
kubectl get nodes
watch kubectl get nodes
```

```
root@iZrj9976wzpibxv39zlxv3Z:~# kubectl get nodes
NAME                      STATUS     ROLES           AGE     VERSION
izrj9976wzpibxv39zlxv3z   Ready      control-plane   5m22s   v1.33.3
izrj9b9nu5j7lbkcipzqj1z   NotReady   <none>          49s     v1.33.3
izrj9hztrcp8hoxgfe9x8cz   NotReady   <none>          40s     v1.33.3
```

在主节点获取当前各容器状态

```
kubectl get pods -n kube-system
```

```
root@iZrj9976wzpibxv39zlxv3Z:~# kubectl get pods -n kube-system
NAME                                              READY   STATUS    RESTARTS   AGE
calico-kube-controllers-7498b9bb4c-289wz          1/1     Running   0          22m
calico-node-7s6sv                                 1/1     Running   0          22m
calico-node-gqttc                                 1/1     Running   0          19m
calico-node-tg9c6                                 1/1     Running   0          19m
coredns-674b8bbfcf-2kqhr                          1/1     Running   0          24m
coredns-674b8bbfcf-7k7s2                          1/1     Running   0          24m
etcd-izrj9976wzpibxv39zlxv3z                      1/1     Running   2          24m
kube-apiserver-izrj9976wzpibxv39zlxv3z            1/1     Running   2          24m
kube-controller-manager-izrj9976wzpibxv39zlxv3z   1/1     Running   2          24m
kube-proxy-8gc7r                                  1/1     Running   0          24m
kube-proxy-q4554                                  1/1     Running   0          19m
kube-proxy-r5n49                                  1/1     Running   0          19m
kube-scheduler-izrj9976wzpibxv39zlxv3z            1/1     Running   2          24m
```

查看集群信息

```
kubectl cluster-info
```









# k8s 命名空间规划

| 分类     | 命名空间名 | 用途说明                                                 | 是否允许业务研发直接部署 |
| -------- | ---------- | -------------------------------------------------------- | ------------------------ |
| 业务服务 | `svc`      | 所有无状态微服务（Java/Go/Node/Python 等）               | ✅ 研发自助               |
| 中间件   | `mid`      | Kafka、RocketMQ、Redis、Mongo、ES、MinIO 等有状态中间件  | ❌ 仅 DBA/中间件组        |
| 持续交付 | `cicd`     | ArgoCD、Tekton、Jenkins、Harbor Registry、ChartMuseum    | ❌ 仅平台组               |
| 可观测性 | `mon`      | Prometheus、Grafana、Loki、Tempo、Alertmanager           | ❌ 仅 SRE                 |
| 流量入口 | `ingress`  | NGINX-Ingress、Istio-Gateway、Cert-manager               | ❌ 仅平台组               |
| 系统增强 | `infra`    | metrics-server、cluster-autoscaler、Volcano、Descheduler | ❌ 仅平台组               |



```
k8s-ns/
├── svc/
│   ├── ns.yaml
│   ├── quota.yaml
│   ├── limitrange.yaml
│   └── netpol-allow-all.yaml
├── mid/
│   ├── ns.yaml
│   ├── quota.yaml
│   ├── limitrange.yaml
│   └── netpol-allow-all.yaml
├── cicd/
│   ├── ns.yaml
│   ├── quota.yaml
│   ├── limitrange.yaml
│   └── netpol-allow-all.yaml
├── mon/
│   ├── ns.yaml
│   ├── quota.yaml
│   ├── limitrange.yaml
│   └── netpol-allow-all.yaml
├── ingress/
│   ├── ns.yaml
│   ├── quota.yaml
│   ├── limitrange.yaml
│   └── netpol-allow-all.yaml
└── infra/
    ├── ns.yaml
    ├── quota.yaml
    ├── limitrange.yaml
    └── netpol-allow-all.yaml
```



业务服务 svc.yaml

```yaml
---
# 1. Namespace 定义
apiVersion: v1
kind: Namespace
metadata:
  name: svc
  labels: {role: svc, env: prod}

---
# 2. ResourceQuota 限制总资源
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-svc
  namespace: svc
spec:
  hard:
    requests.cpu: "200"
    requests.memory: 400Gi
    limits.cpu: "400"
    limits.memory: 800Gi
    count/pods: "500"
    count/services: "100"
    persistentvolumeclaims: "200"

---
# 3. LimitRange 给容器默认资源值
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-svc
  namespace: svc
spec:
  limits:
  - default:      # limits
      cpu: 500m
      memory: 1Gi
    defaultRequest:  # requests
      cpu: 100m
      memory: 128Mi
    type: Container

---
# 4. 网络策略：允许所有（后续可细化）
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all
  namespace: svc
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: [{}]
  egress: [{}]
```

------

中间件 mid.yaml

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: mid
  labels: {role: mid, env: prod}

---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-mid
  namespace: mid
spec:
  hard:
    requests.cpu: "500"
    requests.memory: 1Ti
    limits.cpu: "1000"
    limits.memory: 2Ti
    count/pods: "100"
    count/services: "50"
    persistentvolumeclaims: "300"

---
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-mid
  namespace: mid
spec:
  limits:
  - default:
      cpu: "2"
      memory: 4Gi
    defaultRequest:
      cpu: 500m
      memory: 1Gi
    type: Container

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all
  namespace: mid
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: [{}]
  egress: [{}]
```

------

持续交付 cicd.yaml

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: cicd
  labels: {role: cicd, env: prod}

---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-cicd
  namespace: cicd
spec:
  hard:
    requests.cpu: "100"
    requests.memory: 200Gi
    limits.cpu: "800"   # 编译峰值高
    limits.memory: 1.6Ti
    count/pods: "200"
    count/services: "30"
    persistentvolumeclaims: "100"

---
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-cicd
  namespace: cicd
spec:
  limits:
  - default:
      cpu: "1"
      memory: 2Gi
    defaultRequest:
      cpu: 200m
      memory: 256Mi
    type: Container

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all
  namespace: cicd
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: [{}]
  egress: [{}]
```

------

可观测性 mon.yaml

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: mon
  labels: {role: mon, env: prod}

---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-mon
  namespace: mon
spec:
  hard:
    requests.cpu: "100"
    requests.memory: 200Gi
    limits.cpu: "200"
    limits.memory: 400Gi
    count/pods: "100"
    count/services: "20"
    persistentvolumeclaims: "200"

---
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-mon
  namespace: mon
spec:
  limits:
  - default:
      cpu: 500m
      memory: 1Gi
    defaultRequest:
      cpu: 100m
      memory: 128Mi
    type: Container

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all
  namespace: mon
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: [{}]
  egress: [{}]
```

------

流量入口 ingress.yaml

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: ingress
  labels: {role: ingress, env: prod}

---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-ingress
  namespace: ingress
spec:
  hard:
    requests.cpu: "50"
    requests.memory: 100Gi
    limits.cpu: "100"
    limits.memory: 200Gi
    count/pods: "50"
    count/services: "20"
    persistentvolumeclaims: "10"

---
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-ingress
  namespace: ingress
spec:
  limits:
  - default:
      cpu: 500m
      memory: 512Mi
    defaultRequest:
      cpu: 100m
      memory: 64Mi
    type: Container

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all
  namespace: ingress
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: [{}]
  egress: [{}]
```

------

系统增强 infra.yaml

```yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: infra
  labels: {role: infra, env: prod}

---
apiVersion: v1
kind: ResourceQuota
metadata:
  name: rq-infra
  namespace: infra
spec:
  hard:
    requests.cpu: "20"
    requests.memory: 40Gi
    limits.cpu: "40"
    limits.memory: 80Gi
    count/pods: "50"
    count/services: "20"
    persistentvolumeclaims: "10"

---
apiVersion: v1
kind: LimitRange
metadata:
  name: lr-infra
  namespace: infra
spec:
  limits:
  - default:
      cpu: 200m
      memory: 256Mi
    defaultRequest:
      cpu: 50m
      memory: 64Mi
    type: Container

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all
  namespace: infra
spec:
  podSelector: {}
  policyTypes: ["Ingress", "Egress"]
  ingress: [{}]
  egress: [{}]
```

使用方式

```bash
# 一次性建 6 个 NS 及配套
kubectl apply -f svc.yaml -f mid.yaml -f cicd.yaml -f mon.yaml -f ingress.yaml -f infra.yaml
```









heml



```
# 下载并运行官方安装脚本
curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

# 验证版本
helm version
```



启用 bash 自动补全（可选）

```
# 当前会话立即生效
source <(helm completion bash)

# 永久生效
echo "source <(helm completion bash)" >> ~/.bashrc
source ~/.bashrc
```



















启用 NFS 作为 默认 SC





NFS 服务端，安装在任何机器均可，存储数据

```shell
sudo apt-get update
# 更新本地软件包索引，确保后续安装的软件是最新版本

sudo apt-get -y install nfs-kernel-server
# 安装 NFS 服务器软件包（-y 表示自动确认安装）

sudo mkdir -p /data/nfs
# 创建用于共享的目录，-p 表示如果父目录不存在也一并创建

sudo chmod 777 /data/nfs
# 设置共享目录权限为最大权限（所有用户可读可写可执行），方便测试（生产环境不建议这么做）

echo "/data/nfs *(rw,no_root_squash,sync,insecure,no_subtree_check)" | sudo tee /etc/exports
# 将共享目录配置写入 NFS 的配置文件 /etc/exports
# 参数说明：
# /data/nfs：共享的目录
# *：允许所有客户端访问
# rw：读写权限
# no_root_squash：允许客户端以 root 身份访问
# sync：同步写入磁盘
# insecure：允许客户端使用大于1024的端口连接
# no_subtree_check：禁用子树检查，提高性能

sudo systemctl enable --now nfs-server
# 启动 NFS 服务并设置为开机自启

sudo exportfs -r
# 重新加载 /etc/exports 配置文件，使改动生效

showmount -e localhost
# 查看本机共享的 NFS 目录，验证配置是否成功
# 如果输出中包含 /data/nfs，说明配置正确
```

NFS 客户端

```bash
sudo apt-get update
sudo apt-get -y install nfs-common
```





```shell
# 创建独立命名空间（可选，但推荐）
kubectl create ns nfs-system

# 下载官方最新 manifests
curl -sLO https://raw.githubusercontent.com/kubernetes-sigs/nfs-subdir-external-provisioner/master/deploy/rbac.yaml
curl -sLO https://raw.githubusercontent.com/kubernetes-sigs/nfs-subdir-external-provisioner/master/deploy/deployment.yaml
curl -sLO https://raw.githubusercontent.com/kubernetes-sigs/nfs-subdir-external-provisioner/master/deploy/class.yaml

# 把 deployment.yaml 里的两处占位符换成实际值
# 10.0.1.245
sed -i 's/10.3.243.101/10.0.1.245/g' deployment.yaml
# /data/nfs
sed -i 's|/ifs/kubernetes|/data/nfs|g' deployment.yaml
# 指定命名空间
# nfs-system
sed -i 's/namespace: default/namespace: nfs-system/g' rbac.yaml deployment.yaml class.yaml

# 设为默认sc
sed -i '/name: nfs-client/a\  annotations:\n    storageclass.kubernetes.io/is-default-class: "true"' class.yaml
```





```
kubectl apply -f rbac.yaml
kubectl apply -f deployment.yaml
kubectl apply -f class.yaml
```

验证

```
# 1. 看到 (default)
kubectl get sc

# 2. Pod 运行正常
kubectl -n nfs-system get pod -l app=nfs-client-provisioner

# 3. 快速创建 PVC 测试
kubectl apply -f- <<EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-pvc
spec:
  accessModes: [ReadWriteOnce]
  resources: {requests: {storage: 1Gi}}
EOF

kubectl get pvc   # Bound 即成功

kubectl delete pvc test-pvc
```

- Ubuntu NFS 服务端 `/data/nfs` 会作为公共存储
- 命名空间 `nfs-system` 下的原生 Deployment
- 名为 `nfs-client` 的 **默认** StorageClass
- 任何 PVC 都会自动在该目录下生成子目录，Pod 可直接挂载。
